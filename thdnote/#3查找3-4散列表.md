# 3.4 散列表
- 散列表：用算术操作将键转化为数组的索引来访问数组中的键值对。使用散列的查找算法分为两步：第一步是用 *散列函数* 将被查找的键转化为数组的一个索引。第二步是一个处理 *碰撞冲突* 的过程。两种解决碰撞的方法： *拉链表* 和 *线性探测法* 。
## 3.4.1 散列函数
- 散列函数和键的类型有关。 *对于每种类型的键我们都需要一个与之对应散列函数* 。
- **正整数**：将整数散列最常用方法是 *除留余数法* 。我们选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数。 *素数* 可以有效地将键分布在0到M-1的范围内。
  ![除留余数法](/assets/除留余数法.png)
- **浮点数**：将键表示为二进制数再使用除留余数法。（Java就是这么做的）
- **字符串**：Java的charAt()函数能够返回一个char值，即一个非负16位整数。如果R比任何字符的值都大，这种计算相当于将字符串当作一个N位的R进制值，将它除以M并取余。一种叫Horner方法的经典算法用N次乘法、加法和取余来计算一个字符串的散列值。只要R足够小，不造成溢出没，那么结果就会落在0至M-1之内。使用一个较小的素数，例如31，可以保证字符串中的所有字符都能发挥作用。（Java的String的默认实现使用了一个类似的方法。）下图表示用除留余数法计算String s的散列值。
  ![散列字符串](/assets/散列字符串.png)
- **组合键**：如果键的类型含有多个整数变量，我们可以和String类型一样将它们混合起来。例如，假设被查找的键的类型是Date，其中含有几个整型的域：day（两个数字表示的日），month（两个数字表示的月）和year（4个数字表示的年）。我们可以这样计算它们的散列值：
  > int hash = (((day * R + month) % M) * R + year) % M;
- **Java的约定**：Java令所有数据类型都继承了一个能够返回一个32位整数的`hashCode()`方法。如果要为自定义的数据类型定义散列函数，你需要重写`hashCode()`和`equals()` **两个方法**。
- 因为我们需要的是数组的索引而不是一个32位的整数，我们在实现中会将默认的`hashCode()`方法和除留余数法结合起来产生一个0到M-1的整数，方法如下：
  ```java
  private int hash(Key x)
  { return (x.hashCode() & 0x7fffffff) % M; }
  ```
  这段代码会将符号位屏蔽（将一个32位整数变为一个31位非负整数），然后用除留余数法计算它除以M的余数。
- 本章所有例子中的键的散列值
  ![表3.4.1](/assets/表3.4.1.png)
- **自定义的`hashCode()`方法**：将对象中的每个变量的`hashCode()`返回值转化为32位整数并计算得到散列值。对于原始类型的对象，可以将其转化为对应的数据类型然后再调用`hashCode()`方法：
  ```java
  public class Transaction
  {
    ...
    private final String who;
    private final Date when;
    private final double amount;
    public int hashCode()
    {
      int hash = 17;
      hash = 31 * hash + who.hashCode();
      hash = 31 * hash + when.hashCode();
      hash = 31 * hash + ((Double) amount).hashCode();
      return hash;
    }
    ...
  }
  ```
- **软缓存**：如果散列值的计算很耗时，我们可以在每个键中使用一个hash变量来保存它的`hashCode()`的返回值。第一次调用`hashCode()`方法时，我们需要计算对象的散列值，但之后对`hashCode()`方法的调用会直接返回hash变量的值。（Java的String对象的`hashCode()`方法采用了这种方式）。要为一个数据类型实现一个优秀的散列方法需要满足三个条件：
  - 一致性————等价的键必然产生相等的散列值；
  - 高效性————计算简便；
  - 均匀性————均匀地散列所有的键。

  ![假设3j](/assets/假设3j.png)
## 3.4.2 基于拉链法的散列表
