# 3.2 二叉查找树
定义：一棵**二叉查找树（BST）**是一棵二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。
![图3.2.2](/assets/图3.2.2.png)
## 3.2.1 基本实现
- 算法3.3 基于二叉查找树的符号表
  ```java
  public class BST<Key extends Comparable<key>, Value>
  {
    private Node root;  //二叉查找树的根结点
    private class Node
    {
      private Key keyl;           //键
      private Value val;         //值
      private Node left, right;  //指向子树的链接
      private int N;             //以该结点为根的子树中的结点总数
      public Node(Key key, value val, int N)
      { this.key = key; this.val = val; this.N = N; }
    }
    public int size()
    { return size(root); }
    private int size(Node x)//私有方法size()会将空链接的值当作0，保证：size(x)=size(x.left)+size(x.right)+1
    {
      if(x == null) return 0;
      else return x.N;
    }
    public Value get(Key key)
    //见算法3.3（续1）

    //max()、min()、floor()、ceiling()方法见算法3.3（续2）
    //select()、rank()方法见算法3.3（续3）
    //delete()、deleteMin()、deleteMax()方法见算法3.3（续4）
    //keys()方法见算法3.3（续5）
  }
  ```
- 数据表示：一棵二叉查找树代表了一组键（及其相应的值）的集合，而同一个集合可以用多棵不同的二叉查找树表示。
  ![图3.2.3](/assets/图3.2.3.png)
- 算法3.3（续1）二叉查找树的查找和排序方法的实现
  ![图3.2.4](/assets/图3.2.4.png)
  ```java
  public Value get(Key key)
  { return get(root, key); }
  private Value get(Node x, Key key)
  { //在以x为根结点的子树中查找并返回key所对应的值；如果没找到则返回null
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if (cmp < 0) return get(x.left, key);
    else if (cmp > 0) return get(x.right, key);
    else return x.val;
  }
  public void put(Key key, Value val)
  {//查找key，找到则更新它的值，否则为它创建一个新的结点
    root = put(root, key, val);
  }
  private Node put(Node x, Key key, Value val)
  {
    //如果key存在于以x为根结点的子树中则更新它的值；
    //否则将以key和val为键值对的新结点插入到该子树中
    if (x == null) return new Node(key, val, 1);//如果树为空，就返回一个含有该键值对的新结点
    int cmp = key.compareTo(x.key);
    if (cmp < 0)  x.left = put(x.left, key, val);
    else if (cmp > 0)  x.right = put(x.right, key, val);
    else x.val = val;
    x.N = size(x.left) + size(x.right) + 1;
    return x;
  }
  ```
- 插入
  ![图3.2.5](/assets/图3.2.5.png)
- 递归
  ![图3.2.6](/assets/图3.2.6.png)
- 分析
  ![命题cd](/assets/命题cd.png)
## 3.2.3 有序性相关的方法与删除操作
- 最大键和最小键、向上取整和向下取整：
  ![图3.2.10](/assets/图3.2.10.png)
  算法3.3（续2）二叉查找树中`max()`、`min()`、`floor()`、`ceiling()`方法的实现：
  ```java
  public Key min()
  {
    return min(root).key;
  }
  private Node min(Node x)
  {
    if (x.left == null) return x;
    return min(x.left);
  }
  public Key floor(Key key)
  {
    Node x = floor(root, key);
    if (x == null) return null;
    return x.key;
  }
  private Node floor(Node x, Key key)
  {
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if (cmp == 0) return x;
    if (cmp < 0) return floor(x.left, key);
    Node t = floor(x.right, key);
    if (t != null) return t;
    else return x;
  }
  ```
- 选择、排序：
  - 选择：假设我们想找到排名为k的键（即树中正好有k个小于它的键）。如果左子树中的结点数t大于k，那么我们就继续（递归地）在左子树中查找排名为k的键；如果t等于k，我们就返回根结点中的键；如果t小于k，我们就（递归地）在右子树中查找排名为（k-t-1）的键。
  ![图3.2.11](/assets/图3.2.11.png)
  - 排名：rank()是select()的逆方法，它会返回给定键的排名。如果给定的键和根结点的键相等，我们返回左子树中的结点总数t；如果给定的键小于根结点，我们会返回该键在左子树中的排名（递归计算）；如果给定的键大于根结点，我们会返回t+1（根结点）加上它在右子树中的排名（递归计算）。

算法3.3（续3） 二叉查找树中`select()`和`rank()`方法的实现
  ```java
  public Key select(int k)
  {
    return select(root, k).key;
  }
  private Node select(Node x, int k)
  { //返回排名为k的结点
    if (x == null) return null;
    int t = size(x.left);
    if (t > k) return select(x.left, k);
    else if (t < k) return select(x.right, k-t-1);
    else  return x;
  }
  public int rank(Key key)
  { return rank(key, root); }
  private int rank(Key key, Node x)
  {//返回以x为根结点的子树中小于x.key的键的数量
    if (x == null) return 0;
    int cmp = key.compareTo(x.key);
    if (cmp < 0) return rank(key, x.left);
    else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right);
    else  return size(x.left);
  }
  ```
- 删除最大键和删除最小键、删除操作：
  - 删除最小键所对应的键值对：
  ![图3.2.12](/assets/图3.2.12.png)
  - 删除操作
  
