# 4.4 最短路径

![表4.4.1](/assets/表4.4.1.png)

- 在一幅加权有向图中，从顶点s到顶点t的 **最短路径** 是所有从s到t的路径中的权重最小者。
## 4.4.1 最短路径的性质
- 性质
  - 路径是有向的。
  - 权重不一定等价于距离。
  - 并不是所有顶点都是可达的。
  - 负权重会使问题更复杂。
  - 最短路径一般都是简单的。
  - 最短路径不一定是唯一的。
  - 可能存在平行边和自环；平行边中的权重最小者才会被选中，最短路径也不可能包含自环（除非自环的权重为零，但我们会忽略它）。
- 给定一幅加权有向图和一个顶点s，以s为起点的一棵 **最短路径树(SPT)** 是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。

  ![图4.4.2](/assets/图4.4.2.png)

## 4.4.2 加权有向图的数据结构

![表4.4.2](/assets/表4.4.2.png)

![表4.4.3](/assets/表4.4.3.png)

- 加权有向边的数据类型

  ```java
  public class DirectedEdge
  {
    private final int v;                                 //边的起点
    private final int w;                                 //边的终点
    private fianl double weight;                         //边的权重
    public DirectedEdge(int v, int w, double weight)
    {
      this.v = v;
      this.w = w;
      this.weight = weight;
    }
    public double weight()
    { reutn weight; }
    public int from()
    { return v; }
    public int to()
    { return w; }
    public String toString()
    { return String.format("%d->%d %.2f", v, w, weight); }
  }
  ```

- 加权有向图的数据类型

  ```java
  public class EdgeWeightedDigraph
  {
    private final int V;                         //顶点总数
    private int E;                               //边的总数
    private Bag<DirectedEdge>[] adj;             //邻接表

    public EdgeWeightedDigraph(int V)
    {
      this.V = V;
      this.E = 0;
      adj = (Bag<DirectedEdge>[]) new Bag[V];
      for (int v = 0; v < V; v++)
        adj[v] = new Bag<DirectedEdge>();
    }

    public EdgeWeightedDigraph(In in)   //见练习4.4.2

    public int V() { return V; }
    public int E() { return E; }
    public void addEdge(DirectedEdge e)
    {
      adj[e.from()].add(e);
      E++;
    }
    public Iterable<Edge> adj(int v)
    { return adj[v]; }
    public Iterable<DirectedEdge> edges()
    {
      Bag<DirectedEdge> bag = new Bag<DirectedEdge>();
      for (int v = 0; v < V; v++)
        for(DirectedEdge e : adj[v])
          bag.add(e);
      return bag;
    }
  }
  ```

![图4.4.4](/assets/图4.4.4.png)

- 最短路径的API

  ![表4.4.4](/assets/表4.4.4.png)

- 测试用例

  ```java
  public static void main(String[] args)
  {
    EdgeWeightedDigraph G;
    G = new EdgeWeightedDigraph(new In(args[0]));
    int s = Integer.parseInt(args[1]);
    SP sp = new SP(G, s);

    for (int t = 0; t < G.V(); t++)
    {
      StdOut.print(s + " to " + t);
      StdOut.printf(" (%4.2f): ", sp.distTo(t));
      if (sp.hasPathTo(t))
        for (DirectedEdge e : sp.pathTo(t))
          StdOut.print(e + " ");
      StdOut.println();
    }
  }
  ```

  ![测试4](/assets/测试4.png)

- 边的松弛： *放松* 边v->w意味着检查从s到w的最短路径是否是先从s到v，然后再由v到w。如果是，则根据这个情况更新数据结构的内容。由v到达w的最短路径是distTo[v]与e.weight()之和——如果这个值不小于distTo[w],称这条边 *失效* 了并将它忽略；如果这个值更小，就更新数据。

  ```java
  private void relax(DirectedEdge e)
  {
    int v = e.from(), w = e.to();
    if (distTo[w] > distTo[v] + e.weight())
    {
      distTo[w] = distTo[v] + e.weight();
      edgeTo[w] = e;
    }
  }
  ```

  ![图4.4.6](/assets/图4.4.6.png)

- 顶点的松弛

  ```java
  private void relax(EdgeWeightedDigraph G, int v)
  {
    for (DirectedEdge e : G.adj(v))
    {
      int w = e.to();
      if (distTo[w] > distTo[v] + e.weight())
      {
        distTo[w] = distTo[v] + e.weight();
        edgeTo[w] = e;
      }
    }
  }
  ```

  ![图4.4.7](/assets/图4.4.7.png)

## 4.4.3 最短路径算法的理论基础

- 最优性条件

  ![命题4p](/assets/命题4p.png)

- 通用算法

  ![命题4q](/assets/命题4q.png)

## 4.4.4 Dijkstra算法

- 首先将distTo[s]初始化为0，distTo[]中的其他元素初始化为正无穷。然后将distTo[]最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的distTo[]值均为无穷大。

  ![命题4r](/assets/命题4r.png)

- 算法构造最短路径树的过程如下
  - 将顶点0添加到树中，将顶点2和4加入优先队列。
  - 从优先队列中删除顶点2，将0→2添加到树中，将顶点7加入优先队列。
  - 从优先队列中删除顶点4，将0→4添加到树中，将顶点5加入优先队列，边4→7失效。
  - 从优先队列中删除顶点7，将2→7添加到树中，将顶点3加入优先队列，边7→5失效。
  - 从优先队列中删除顶点5，将4→5添加到树中，将顶点1加入优先队列，边5→7失效。
  - 从优先队列中删除顶点3，将7→3添加到树中，将顶点6加入优先队列。
  - 从优先队列中删除顶点1，将5→1添加到树中，边1→3失效。
  - 从优先队列中删除顶点6，将3→6添加到树中。

    ![图4.4.10](/assets/图4.4.10.png)

- 算法4.9 最短路径的Dijkstra算法

  ```java
  public class DijkstraSP
  {
    private DirectedEdge[] edgeTo;
    private double[] distTo;
    private IndexMinPQ<Double> pq;

    public DijkstraSP(EdgeWeightedDigraph G, int s)
    {
      edgeTo = new DirectedEdge[G.V()];
      distTo = new double[G.V()];
      pq = new IndexMinPQ<Double>(G.V());
      for (int v = 0; v < G.V(); v++)
        distTo[v] = Double.POSITIVE_INFINITY;
      distTo[s] = 0.0;

      pq.insert(s, 0.0);
      while (!pq.isEmpty())
        relax(G, pq.delMin())
    }
    private void relax(EdgeWeightedDigraph G, int v)
    {
      for(DirectedEdge e : G.adj(v))
      {
        int w = e.to();
        if (distTo[w] > distTo[v] + e.weight())
        {
          distTo[w] = distTo[v] + e.weight();
          edgeTo[w] = e;
          if (pq.contains(w))  pq.change(w, distTo[w]);//边的to()得到的顶点还不在优先队列中，此时需要使用insert()方法将它加入到优先队列中；
          else  pq.insert(w, distTo[w]);     //边的to()得到的顶点还不在优先队列汇总，此时需要使用insert()方法将它加入到优先队列中；
        }
      }
    }
    public double distTo(int v)               //最短路径树实现中的标准查询算法
    { return distTo[v]; }
    public boolean hasPathTo(int v)
    { return distTo[v] < Double.POSITIVE_INFINITY; }
    public Iterable<Edge> pathTo(int v)
    {
      if (!hasPathTo(v))  return null;
      Stack<DirectedEdge> path = new Stack<DirectedEdge>();
      for (DirectedEdge e = edgeTo[v];e != null;e = edgeTo[e.from()])
        path.push(e);
      return path;
    }
  }
  ```
