# 有向图

## 4.2.1 术语

- 一幅 **有向图** 是由一组 **顶点** 和一组 **有方向的边** 组成的，每条有方向的边都连接着有序的一对顶点。
- 一条有向边由第一个顶点指出并指向第二个顶点。一个顶点的 **出度** 为由该顶点指出的边的总数；一个顶点的 **入度** 为指向该顶点的边的总数。一条有向边的第一个顶点称为 *头* ，第二个顶点称为 *尾* 。
- 在一幅有向图中， **有向路径** 由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。 **有向环** 为一条至少含有一条边且起点和终点相同的有向路径。 **简单有向环** 是一条（除了起点和终点必须相同之外）不含有重复的顶点和边的环。路径或者环的 **长度** 即为其中所包含的边数。

  ![图4.1.21](/assets/图4.1.21_a75t5vhlp.png)

## 4.2.2 有向图的数据类型

![表4.2.2](/assets/表4.2.2.png)

- Digraph 数据类型：Digraph数据类型与Graph数据类型基本相同，区别是addEdge()只调用了一次add()，而且它还有一个reverse()方法来返回图的反向图。

  ```java
  public class Digraph
  {
    private final int V;
    private int E;
    private Bag<Integer>[] adj;
    public Digraph(int V)
    {
      this.V = V;
      this.E = 0;
      adj =(Bag<Integer>[]) new Bag[V];
      for (int v = 0; v < V; v++)
        adj[v] = new Bag<Integer>();
    }
    public int V() { return V; }
    public int E() { return E; }
    public void addEdge(int v, int w)
    {
      adj[v].add(w);
      E++;
    }
    public Iterable<Integer> adj(int v)
    { return adj[v]; }
    public Digraph reverse()
    {
      Digraph R = new Digraph(V);
      for (int V = 0; v < V; v++)
        for (int w : adj(v))
          R.addEdge(w, v);
      return R;
    }
  }
  ```

## 4.2.3 有向图中的可达性

![表4.2.3](/assets/表4.2.3.png)

![命题4d](/assets/命题4d.png)

- 算法4.4 有向图的可达性。这份深度优先搜索的实现使得用例能够判断从给定的一个或者一组顶点能到达哪些其他顶点。

  ```java
  public class DirectedDFS
  {
    private boolean[] marked;
    public DirectedDFS(Digraph G, int s)
    {
      marked = new boolean[G.V()];
      dfs(G, s);
    }
    public DirectedDFS(Digraph G, Iterable<Integer> sources)
    {
      marked = new boolean[G.V()];
      for (int s : sources)
        if (!marked[s]) dfs(G, s);
    }
    private void dfs(Digraph G, int v)
    {
      marked[v] = true;
      for (int w : G.adj(v))
        if (!marked[w]) dfs(G, w);
    }
    public boolean marked(int v)
    { return marked[v]; }
    public static void main(String[] args)
    {
      Digraph G = new Digraph(new In(args[0]));
      Bag<Integer> sources = new Bag<Integer>();
      for (int i = 1; i < args.length; i++)
        sources.add(Integer.parseInt(args[i]));
      DirectedDFS reachable = new DirectedDFS(G, sources);
      for (int v = 0; v < G.V(); v++)
        if (reachable.marked(v)) StdOut.print(v + " ");
      StdOut.println();
    }
  }
  ```

  ![图4.2.3](/assets/图4.2.3.png)

- 标记-清除的垃圾收集：多点可达性的一个重要应用是在 **内存管理系统** 中。在一幅有向图中，一个顶点表示一个对象，一条边表示一个对象对另一个对象的引用。
