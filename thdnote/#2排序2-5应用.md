# 2.5 应用
## 2.5.1 将各种数据排序
- 指针排序：我们使用的方法在经典教材中被称为**指针排序**，因为我们只处理元素的引用而不移动数据本身。
- 不可变的键：如果在排序后用例还能够修改键值，那么数组就很可能不再是有序的了。在Java中，可以用不可变的数据类型作为键来避免这个问题。如String、Integer、Double和File等。
- 廉价的交换：使用引用的另一个好处是我们不必移动整个元素。对于元素大而键小的数组来说这带来的节约是巨大的，因为比较只需要访问元素的一小部分，而排序过程中大部分元素都不会被访问到。
- 多种排序方法：在很多应用中我们都希望根据情况将一组对象按照不同的方式排序。Java的Comparator接口允许我们在一个类之中实现多种排序方法。用Comparator接口来代替Comparable接口能够更好地将数据类型的定义和两个该类型的对象应该如何比较的定义区分开来。
- 多键数组：一般在应用程序中，一个元素的多种属性都可能被用作排序的键。
- 稳定性：如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是**稳定**的。

## 2.5.2 应该使用哪种排序算法
  ![表2.5.1](/assets/表2.5.1.png)
  ![性质t](/assets/性质t.png)
- 将原始类型数据排序：一些性能优先的应用的重点可能是将数字排序，因此更合理的做法是跳过引用直接将袁术数据类型的数据排序。例如，将一个double类型的数组我们可以直接交换这些数并将数组排序；而对于Double类型的数组我们交换的是存储了这些数字的Double对象的引用。如果我们只是在将一大数组排序的话，跳过引用可以为我们节省存储所有引用所需的空间和通过引用来访问数字的成本。
- Java系统库的排序算法：Java的系统程序员选择对原始数据类型使用（三向切分的）快速排序，对引用类型使用归并排序。这些选择实际上也暗示着用速度和空间（对于原始数据类型）来换取稳定性（对于引用类型）。当为实际应用开发java程序时，你会发现Java的Arrays.sort()实现（可能再加上自己实现的compareTo()或者compare()）已经基本够用了。
## 2.5.3 问题的归约
- 归约指的是为解决某个问题而发明的算法正好可以用来解决另一种问题。
- 找出重复元素：首先将数组排序，然后遍历有序的数组，记录连续出现的重复元素即可。
  ```java
  统计a[]中不重复元素的个数：
  Quick.sort(a);
  int count = 1;
  for(int i = 1; i < a.length; i++)
    if(a[i].compareTo(a[i-1]) != 0)
      count++;
  ```
- 排名：一组排列（或是排名）就是一组N个整数的数组，其中0到N-1的每个数都只出现一次。两个排列之间的Kendall tau距离就是在两组数列中顺序不同的数对的数目。某个排列和标准排列（即每个元素都在正确位置上的排序）的Kendall tau距离就是其中逆序数对的数量。
  > 例如，0 3 1 6 2 5 4和1 0 3 6 4 2 5之间的Kendall tau距离是4，因为0-1、3-1、2-4、5-4这四对数字在两组排列中的相对顺序不同。
- 优先队列
- 中位数与顺序统计：一个和排序有关但又不需要完全排序的重要应用就是找出一组元素的**中位数**。可以用快速排序的切分来查找中位数。
  ![图2.5.2](/assets/图2.5.2.png)

## 2.5.4 排序应用一览
- 商业计算
- 信息搜索
- 运筹学
- 事件驱动模拟
- 数值计算
- 组合搜索
