# 1.3 背包（Bag）、队列（Queue）和栈（Stack）
# 1.3.1 集合型抽象数据类型
![表1.3.1](/assets/表1.3.1.png)
![表1.3.1续](/assets/表1.3.1续.png)
- 集合类的抽象数据类型的一个*关键特性*：可以用它们存储任意类型的数据，称为**泛型**或**参数化类型**。
  API中，类名后的`<Item>`记号将`Item`定义为一个*类型参数*。它是一个象征性的占位符，表示的是用例将会使用的某种具体数据类型。
  例如，编写用栈来处理`String`对象：
  ```java
  Stack<String> stack = new Stack<String>();
  stack.push("Test");
  ...
  String next = stack.pop();
  ```
  使用队列处理Date对象：
  ```java
  Queue<Date> queue = new Queue<Date>();
  queue.enqueue(new Date(12, 31, 1999));
  ...
  Date next = queue.dequeue();
  ```
- 类型参数必须被实例化为引用参数。java的封装类型都是原始数据类型对应的引用类型：Boolean、Byte、Character、Double、Float、Integer、Long和Short分别对应着boolean、byte、character、double、float、integer、long和short。在处理赋值语句、方法的参数和算术或逻辑表达式时，java会*自动*在引用类型和对应的原始数据类型之间进行转换。
  ```java
  Stack<Integer> stack = new Stack<Integer>();
  stack.push(17);//自动装箱（int -> Integer）
  int i = stack.pop();//自动拆箱（INteger -> int）
  ```
- 迭代访问集合中的所有元素
  例如，假设用例在Queue中维护一个交易集合
  ```java
  Queue<Transaction> collection = new Queue<Transaction>();
  如果集合是可迭代的，用例用一行语句即可打印出交易的列表：
  for (Transaction t : collection){ StdOut.print(t);}
  ```
  这种语法叫`foreach`语句
- **背包**是一种不支持从中删除元素的集合数据类型——它的目的是帮助用例收集元素并迭代遍历所有收集到的元素（用例也可以检查背包是否为空或者获取背包中元素的数量）。*迭代的顺序不确定且与用例无关。*
![图1.3。1](/assets/图1.3。1.png)
图1.3.1 简单的计算输入中所有`double`值的平均值和样本标准差。注意：不需要保存所有的数也可以计算标准差。
```java
public ckass Stats
{
  public static void main(String[] args)
  {
    Bag<Double> numbers = new Bag<Double>();
    while(!StdIn.isEmpty())
        numbers.add(StdIn.readDouble());
    int N = numbers.size();
    double sum = 0.0;
    for (double x : numbers)
        sum += x;
    double mean = sum/N;
    sum = 0.0;
    for(double x : numbers)
        sum +=(x - mean)*(x - mean);
    double std = Math.sqrt(sum/(N-1));
    StdOut.printf("Mean: %.2f\n", mean);
    StdOut.printf("Std dev: %.2f\n", std);
  }
}
```
- **队列**一种基于先进先出（FIFO）策略的集合类型。用集合保存元素的同时保存它们的相对顺序：是它们入列顺序和出列顺序相同。
  ![图1.3.2](/assets/图1.3.2.png)
  ```java
  In类的静态方法readInts()的一种实现，该方法解决的问题：用例无需预先知道文件的大小即可将文件中的所有整数读入一个数组中。
  public static int[] readInts(String name)
  {
    In in = new In(name);
    Queue<Integer> q = new Queue<Integer>();
    while (!in.isEmpty())
        q.enqueue(in.readInt());
    int N = q.size();
    int [] a = new int[N];
    for (int i = 0; i < N; i++)
        a[i] = q.dequeue();
    return a;
  }
  ```
- **栈**一种基于后进先出（LIFO）策略的集合类型。
  ![图1.3.3](/assets/图1.3.3.png)
  ```java
  把标准输入中的所有整数逆序排列，无需预先知道整数的多少。
  public class Reverse
  {
    public static void main(String[] args)
    {
      Stack<Integer> stack;
      stack = new Stack<Integer>();
      while(!StdIn.isEmpty())
          stack.push(StdIn.readInt());
      for (int i : stack)
          StdOut.println(i);
    }
  }
  ```
  
