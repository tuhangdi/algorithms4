# 5.1 字符串排序

![表5.0.2](/assets/表5.0.2.png)

## 5.1.1 键索引计数法

- 一种是用于小整数键的简单排序方法

  ![图5.1.1](/assets/图5.1.1.png)

- 频率统计
  - 使用int数组count[]计算每个键出现的平率。如果键为r，则将count[r+1]加1。

  ![图5.1.2](/assets/图5.1.2.png)

- 将频率转换为索引
  - 使用count[]来计算每个键在排序结果中的起始索引位置。

  ![图5.1.3](/assets/图5.1.3.png)

- 数据分类
  - 将所有元素（学生）移动到一个辅助数组aux[]中以进行排序。每个元素在aux[]中的位置是由它的键（组别）对应的count[]值决定，在移动之后将count[]中对应元素的值加1，以保证count[r]总是下一个键为r的元素在aux[]中的索引位置。

  ![图5.1.4](/assets/图5.1.4.png)

  ![图5.1.5](/assets/图5.1.5.png)

- 回写
  - 将排序的结果复制回原数组中。

![命题5a](/assets/命题5a.png)

- 键索引计数法（a[].key()为[0, R]之间的一个整数）

  ```java
  int N = a.length;

  String[] aux = new String[N];
  int[] count = new int[R+1];

  //计算出现频率
  for (int i = 0; i < N; i++)
    count[a[i].key() + 1]++;
  //将频率转换为索引
  for (int r = 0; r < R; r++)
    count[r+1] += count[r];
  //将元素分类
  for (int i = 0; i < N; i++)
    aux[count[a[i].key()]++] = a[i];
  //回写
  for (int i = 0; i < N; i++)
    a[i] = aux[i];
  ```

## 5.1.2 低位优先(LSD)的字符串排序

![命题5b](/assets/命题5b.png)

- 算法5.1 低位优先的字符串排序

  ```java
  public class LSD
  {
    public static void sort(String[] a, int w)
    {  //通过前W个字符将a[]排序
      int N = a.length;
      int R = 256;
      String[] aux = new String[N];

      for(int d = W-1; d >= 0; d--)
      {  // 根据第d个字符用键索引技术法排序
        int[] count = new int[R+1];    //计算出现频率
        for (int i = 0; i < N; i++)
          count[a[i].charAt(d) + 1]++;

        for (int r = 0; r < R; r++)    //将频率转换为索引
          count[r+1] += count[r];

        for (int i = 0; i < N; i++)    //将元素分类
          aux[count[a[i].charAt(d)]++] = a[i];

        for (int i = 0; i < N; i++)    //回写
          a[i] = aux[i];
      }
    }
  }
  ```

  ![算法5.1](/assets/算法5.1.png)

  
