# 2.2 归并排序
归并排序最吸引人的性质就是它能够保证将任意长度为$N$的数组排序所需时间和$NlogN$成正比；它主要的确定则是它所需要的额外空间和$N$成正比。
## 2.2.1 原地归并的抽象方法
- 该方法先将 所有元素复制到aux[]中，然后再归并回a[]中。方法在归并时（第二个for循环）进行了4个条件判断：左半边用尽（取右半边的元素）、右半边用尽（取左半边的元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）以及右半边的当前元素大于等于左半边的当前元素（取左半边的元素）。
  ```java
  public static void merge(Comparable[] a, int lo, int mid, int hi)
  {//将a[lo..mid]和a[mid+1..hi]归并
    int i = lo,j = mid+1;
    for(int k = lo; k <=hi; k++)//强a[lo..hi]复制到aux[lo..hi]
      aux[k] = a[k];
    for (int k = lo; k <= hi; k++)//归并回到a[lo..hi]
      if (i > mid)
        a[k] = aux[j++];
      else if(j >hi)
        a[k] = aux[i++];
      else if(less(aux[j], aux[i]))
        a[k] = aux[j++];
      else
        a[k] = aux[i++];
  }
  ```
  ![图2.2.1原](/assets/图2.2.1原.png)

## 2.2.2 自顶向下的归并排序
- 递归归并，利用分治思想。
  ```java
  public class Merge
  {
    private static Comparable[] aux; //归并所需的辅助数组
    public static void sort(Comparable[] a)
    {
      aux = new Comparable[a.length]; //一次性分配空间
      sort(a, 0, a.length - 1);
    }
    private static void sort(Comparable[] a, int lo, int hi)
    {//将数组a[lo..hi]排序
      if (hi <= lo) return;
      int mid = lo + (hi - lo)/2;
      sort(a, lo, mid);  //将左半边排序
      sort(a, mid+1, hi); //将右半边排序
      merge(a, lo, mid, hi);//归并结果 ，见上
    }
  }
  ```
  ![图2.2.1自顶](/assets/图2.2.1自顶.png)
  ![命题f](/assets/命题f.png)
  ![命题g](/assets/命题g.png)
- 命题f和命题g告诉我们归并排序所需的时间和$NlgN$成正比
